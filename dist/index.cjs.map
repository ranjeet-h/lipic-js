{"version":3,"sources":["../src/index.ts","../maps/devanagari/base.json","../maps/marathi/phonetic.base.json","../maps/marathi/phonetic.expanded.json","../src/engine/trie.ts","../src/engine/input-stack.ts","../src/engine/rules/ligature.ts","../src/engine/rules/types.ts","../src/engine/rules/nasalization.ts","../src/engine/rules/nukta.ts","../src/engine/rules/schwa.ts","../src/engine/rules/index.ts","../src/engine/transliteration-engine.ts","../src/integrations/dom-integrator.ts","../src/integrations/contenteditable-edit.ts","../src/integrations/input-interceptor.ts"],"sourcesContent":["import devanagariBase from \"../maps/devanagari/base.json\";\nimport marathiPhoneticBase from \"../maps/marathi/phonetic.base.json\";\nimport marathiPhoneticExpanded from \"../maps/marathi/phonetic.expanded.json\";\nexport { buildTrie, walkLongest } from \"./engine/trie\";\nexport { createInputStack } from \"./engine/input-stack\";\nexport { createTransliterationEngine } from \"./engine/transliteration-engine\";\nexport { deleteAndInsert, DOMIntegrator } from \"./integrations/dom-integrator\";\nexport { createInputInterceptor } from \"./integrations/input-interceptor\";\nexport { deleteAndInsertContentEditable } from \"./integrations/contenteditable-edit\";\nexport type { EngineRuleOptions, NasalizationMode } from \"./engine/rules/types\";\nexport type { InputStack } from \"./engine/input-stack\";\nexport type {\n  InputInterceptor,\n  InputInterceptorOptions,\n  InterceptTarget\n} from \"./integrations/input-interceptor\";\nexport type {\n  ContentEditableEditResult\n} from \"./integrations/contenteditable-edit\";\nexport type {\n  LongestMatchResult,\n  TrieNode\n} from \"./engine/trie\";\nexport type {\n  TransliterationEngine,\n  TransliterationEngineOptions,\n  TransliterationEntry\n} from \"./engine/transliteration-engine\";\nexport type { TextInputLike } from \"./integrations/dom-integrator\";\n\nexport type Edit = { backspace: number; insert: string };\n\nexport const maps = {\n  devanagari: {\n    base: devanagariBase\n  },\n  marathi: {\n    phonetic: {\n      base: marathiPhoneticBase,\n      expanded: marathiPhoneticExpanded\n    }\n  }\n} as const;\n\nexport { devanagariBase, marathiPhoneticBase, marathiPhoneticExpanded };\n","{\n  \"consonants\": [\n    \"क\",\n    \"ख\",\n    \"ग\",\n    \"घ\",\n    \"ङ\",\n    \"च\",\n    \"छ\",\n    \"ज\",\n    \"झ\",\n    \"ञ\",\n    \"ट\",\n    \"ठ\",\n    \"ड\",\n    \"ढ\",\n    \"ण\",\n    \"त\",\n    \"थ\",\n    \"द\",\n    \"ध\",\n    \"न\",\n    \"प\",\n    \"फ\",\n    \"ब\",\n    \"भ\",\n    \"म\",\n    \"य\",\n    \"र\",\n    \"ल\",\n    \"व\",\n    \"श\",\n    \"ष\",\n    \"स\",\n    \"ह\",\n    \"ळ\"\n  ],\n  \"vowelsIndependent\": [\n    \"अ\",\n    \"आ\",\n    \"इ\",\n    \"ई\",\n    \"उ\",\n    \"ऊ\",\n    \"ऋ\",\n    \"ॠ\",\n    \"ऌ\",\n    \"ॡ\",\n    \"ए\",\n    \"ऐ\",\n    \"ओ\",\n    \"औ\",\n    \"ॲ\",\n    \"ऑ\"\n  ],\n  \"vowelMatras\": [\n    \"ा\",\n    \"ि\",\n    \"ी\",\n    \"ु\",\n    \"ू\",\n    \"ृ\",\n    \"ॄ\",\n    \"ॢ\",\n    \"ॣ\",\n    \"े\",\n    \"ै\",\n    \"ो\",\n    \"ौ\",\n    \"ॅ\",\n    \"ॉ\"\n  ],\n  \"halant\": \"्\",\n  \"digits\": [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\"],\n  \"marks\": {\n    \"anusvara\": \"ं\",\n    \"chandrabindu\": \"ँ\",\n    \"visarga\": \"ः\"\n  }\n}\n\n","{\n  \"a\": { \"type\": \"vowel\", \"glyph\": \"अ\", \"matra\": \"\" },\n  \"aa\": { \"type\": \"vowel\", \"glyph\": \"आ\", \"matra\": \"ा\" },\n  \"i\": { \"type\": \"vowel\", \"glyph\": \"इ\", \"matra\": \"ि\" },\n  \"ii\": { \"type\": \"vowel\", \"glyph\": \"ई\", \"matra\": \"ी\" },\n  \"u\": { \"type\": \"vowel\", \"glyph\": \"उ\", \"matra\": \"ु\" },\n  \"uu\": { \"type\": \"vowel\", \"glyph\": \"ऊ\", \"matra\": \"ू\" },\n  \"ri\": { \"type\": \"vowel\", \"glyph\": \"ऋ\", \"matra\": \"ृ\" },\n  \"e\": { \"type\": \"vowel\", \"glyph\": \"ए\", \"matra\": \"े\" },\n  \"ai\": { \"type\": \"vowel\", \"glyph\": \"ऐ\", \"matra\": \"ै\" },\n  \"o\": { \"type\": \"vowel\", \"glyph\": \"ओ\", \"matra\": \"ो\" },\n  \"au\": { \"type\": \"vowel\", \"glyph\": \"औ\", \"matra\": \"ौ\" },\n  \"ae\": { \"type\": \"vowel\", \"glyph\": \"ॲ\", \"matra\": \"ॅ\" },\n  \"aw\": { \"type\": \"vowel\", \"glyph\": \"ऑ\", \"matra\": \"ॉ\" },\n\n  \"k\": { \"type\": \"consonant\", \"glyph\": \"क\" },\n  \"kh\": { \"type\": \"consonant\", \"glyph\": \"ख\" },\n  \"g\": { \"type\": \"consonant\", \"glyph\": \"ग\" },\n  \"gh\": { \"type\": \"consonant\", \"glyph\": \"घ\" },\n  \"ng\": { \"type\": \"consonant\", \"glyph\": \"ङ\" },\n\n  \"ch\": { \"type\": \"consonant\", \"glyph\": \"च\" },\n  \"chh\": { \"type\": \"consonant\", \"glyph\": \"छ\" },\n  \"j\": { \"type\": \"consonant\", \"glyph\": \"ज\" },\n  \"jh\": { \"type\": \"consonant\", \"glyph\": \"झ\" },\n  \"ny\": { \"type\": \"consonant\", \"glyph\": \"ञ\" },\n\n  \"T\": { \"type\": \"consonant\", \"glyph\": \"ट\" },\n  \"Th\": { \"type\": \"consonant\", \"glyph\": \"ठ\" },\n  \"D\": { \"type\": \"consonant\", \"glyph\": \"ड\" },\n  \"Dh\": { \"type\": \"consonant\", \"glyph\": \"ढ\" },\n  \"N\": { \"type\": \"consonant\", \"glyph\": \"ण\" },\n\n  \"t\": { \"type\": \"consonant\", \"glyph\": \"त\" },\n  \"th\": { \"type\": \"consonant\", \"glyph\": \"थ\" },\n  \"d\": { \"type\": \"consonant\", \"glyph\": \"द\" },\n  \"dh\": { \"type\": \"consonant\", \"glyph\": \"ध\" },\n  \"n\": { \"type\": \"consonant\", \"glyph\": \"न\" },\n\n  \"p\": { \"type\": \"consonant\", \"glyph\": \"प\" },\n  \"ph\": { \"type\": \"consonant\", \"glyph\": \"फ\" },\n  \"b\": { \"type\": \"consonant\", \"glyph\": \"ब\" },\n  \"bh\": { \"type\": \"consonant\", \"glyph\": \"भ\" },\n  \"m\": { \"type\": \"consonant\", \"glyph\": \"म\" },\n\n  \"y\": { \"type\": \"consonant\", \"glyph\": \"य\" },\n  \"r\": { \"type\": \"consonant\", \"glyph\": \"र\" },\n  \"l\": { \"type\": \"consonant\", \"glyph\": \"ल\" },\n  \"v\": { \"type\": \"consonant\", \"glyph\": \"व\" },\n  \"L\": { \"type\": \"consonant\", \"glyph\": \"ळ\" },\n\n  \"sh\": { \"type\": \"consonant\", \"glyph\": \"श\" },\n  \"Sh\": { \"type\": \"consonant\", \"glyph\": \"ष\" },\n  \"s\": { \"type\": \"consonant\", \"glyph\": \"स\" },\n  \"h\": { \"type\": \"consonant\", \"glyph\": \"ह\" },\n\n  \"M\": { \"type\": \"mark\", \"glyph\": \"ं\" },\n  \"MM\": { \"type\": \"mark\", \"glyph\": \"ँ\" },\n  \"H\": { \"type\": \"mark\", \"glyph\": \"ः\" }\n}\n\n","{\n  \"a\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"अ\",\n    \"matra\": \"\"\n  },\n  \"A\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"आ\",\n    \"matra\": \"ा\"\n  },\n  \"ā\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"आ\",\n    \"matra\": \"ा\"\n  },\n  \"aa\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"आ\",\n    \"matra\": \"ा\"\n  },\n  \"ae\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ॲ\",\n    \"matra\": \"ॅ\"\n  },\n  \"ai\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऐ\",\n    \"matra\": \"ै\"\n  },\n  \"au\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"औ\",\n    \"matra\": \"ौ\"\n  },\n  \"aw\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऑ\",\n    \"matra\": \"ॉ\"\n  },\n  \"b\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ब\"\n  },\n  \"bh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"भ\"\n  },\n  \"ch\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"च\"\n  },\n  \"chh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"छ\"\n  },\n  \"d\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"द\"\n  },\n  \"D\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ड\"\n  },\n  \"dh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ध\"\n  },\n  \"Dh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ढ\"\n  },\n  \"dny\": {\n    \"type\": \"conjunct\",\n    \"glyph\": \"ज्ञ\"\n  },\n  \"e\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ए\",\n    \"matra\": \"े\"\n  },\n  \"ee\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ई\",\n    \"matra\": \"ी\"\n  },\n  \"g\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ग\"\n  },\n  \"gh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"घ\"\n  },\n  \"gy\": {\n    \"type\": \"conjunct\",\n    \"glyph\": \"ज्ञ\"\n  },\n  \"h\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ह\"\n  },\n  \"H\": {\n    \"type\": \"mark\",\n    \"glyph\": \"ः\"\n  },\n  \"i\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"इ\",\n    \"matra\": \"ि\"\n  },\n  \"I\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ई\",\n    \"matra\": \"ी\"\n  },\n  \"ī\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ई\",\n    \"matra\": \"ी\"\n  },\n  \"ii\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ई\",\n    \"matra\": \"ी\"\n  },\n  \"j\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ज\"\n  },\n  \"jh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"झ\"\n  },\n  \"k\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"क\"\n  },\n  \"kh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ख\"\n  },\n  \"l\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ल\"\n  },\n  \"L\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ळ\"\n  },\n  \"m\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"म\"\n  },\n  \"M\": {\n    \"type\": \"mark\",\n    \"glyph\": \"ं\"\n  },\n  \"MM\": {\n    \"type\": \"mark\",\n    \"glyph\": \"ँ\"\n  },\n  \"n\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"न\"\n  },\n  \"N\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ण\"\n  },\n  \"ng\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ङ\"\n  },\n  \"ny\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ञ\"\n  },\n  \"o\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ओ\",\n    \"matra\": \"ो\"\n  },\n  \"p\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"प\"\n  },\n  \"ph\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"फ\"\n  },\n  \"r\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"र\"\n  },\n  \"R\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"र\"\n  },\n  \"ri\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऋ\",\n    \"matra\": \"ृ\"\n  },\n  \"s\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"स\"\n  },\n  \"sh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"श\"\n  },\n  \"Sh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ष\"\n  },\n  \"t\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"त\"\n  },\n  \"T\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ट\"\n  },\n  \"th\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"थ\"\n  },\n  \"Th\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ठ\"\n  },\n  \"u\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"उ\",\n    \"matra\": \"ु\"\n  },\n  \"U\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऊ\",\n    \"matra\": \"ू\"\n  },\n  \"ū\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऊ\",\n    \"matra\": \"ू\"\n  },\n  \"uu\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ऊ\",\n    \"matra\": \"ू\"\n  },\n  \"v\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"व\"\n  },\n  \"w\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"व\"\n  },\n  \"W\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"व\"\n  },\n  \"x\": {\n    \"type\": \"conjunct\",\n    \"glyph\": \"क्ष\"\n  },\n  \"y\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"य\"\n  },\n  \"B\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ब\"\n  },\n  \"G\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ग\"\n  },\n  \"J\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ज\"\n  },\n  \"K\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"क\"\n  },\n  \"P\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"प\"\n  },\n  \"V\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"व\"\n  },\n  \"X\": {\n    \"type\": \"conjunct\",\n    \"glyph\": \"क्ष\"\n  },\n  \"Y\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"य\"\n  },\n  \"E\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ए\",\n    \"matra\": \"े\"\n  },\n  \"O\": {\n    \"type\": \"vowel\",\n    \"glyph\": \"ओ\",\n    \"matra\": \"ो\"\n  },\n  \"Ch\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"च\"\n  },\n  \"Ph\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"फ\"\n  },\n  \"Bh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"भ\"\n  },\n  \"Gh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"घ\"\n  },\n  \"Kh\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ख\"\n  },\n  \"Ny\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ञ\"\n  },\n  \"Ng\": {\n    \"type\": \"consonant\",\n    \"glyph\": \"ङ\"\n  }\n}","export interface TrieNode<TValue> {\n  children: Map<string, TrieNode<TValue>>;\n  terminal: null | {\n    key: string;\n    value: TValue;\n  };\n}\n\nexport interface LongestMatchResult<TValue> {\n  isPrefix: boolean;\n  matched: boolean;\n  key: string;\n  value: TValue | null;\n  length: number;\n}\n\nfunction createNode<TValue>(): TrieNode<TValue> {\n  return {\n    children: new Map<string, TrieNode<TValue>>(),\n    terminal: null\n  };\n}\n\nexport function buildTrie<TValue>(expandedMap: Record<string, TValue>): TrieNode<TValue> {\n  const root = createNode<TValue>();\n\n  for (const [key, value] of Object.entries(expandedMap)) {\n    if (key.length === 0) {\n      continue;\n    }\n\n    let node = root;\n    for (const ch of key) {\n      let child = node.children.get(ch);\n      if (!child) {\n        child = createNode<TValue>();\n        node.children.set(ch, child);\n      }\n      node = child;\n    }\n\n    node.terminal = { key, value };\n  }\n\n  return root;\n}\n\nexport function walkLongest<TValue>(\n  root: TrieNode<TValue>,\n  input: string,\n  startIndex = 0\n): LongestMatchResult<TValue> {\n  let node: TrieNode<TValue> | undefined = root;\n  let index = startIndex;\n  let matchedLength = 0;\n  let matchedKey = \"\";\n  let matchedValue: TValue | null = null;\n\n  while (node && index < input.length) {\n    const ch = input[index];\n    const next = node.children.get(ch);\n    if (!next) {\n      return {\n        isPrefix: false,\n        matched: matchedLength > 0,\n        key: matchedKey,\n        value: matchedValue,\n        length: matchedLength\n      };\n    }\n\n    node = next;\n    index += 1;\n\n    if (node.terminal) {\n      matchedLength = index - startIndex;\n      matchedKey = node.terminal.key;\n      matchedValue = node.terminal.value;\n    }\n  }\n\n  return {\n    isPrefix: Boolean(node) && index === input.length,\n    matched: matchedLength > 0,\n    key: matchedKey,\n    value: matchedValue,\n    length: matchedLength\n  };\n}\n","export interface InputStack {\n  push(char: string): void;\n  pop(): string | undefined;\n  clear(): void;\n  toString(): string;\n  size(): number;\n  isEmpty(): boolean;\n}\n\nexport function createInputStack(): InputStack {\n  const parts: string[] = [];\n\n  return {\n    push(char: string): void {\n      parts.push(char);\n    },\n    pop(): string | undefined {\n      return parts.pop();\n    },\n    clear(): void {\n      parts.length = 0;\n    },\n    toString(): string {\n      return parts.join(\"\");\n    },\n    size(): number {\n      return parts.length;\n    },\n    isEmpty(): boolean {\n      return parts.length === 0;\n    }\n  };\n}\n","import type { RuleContext, RuleFn, Token } from \"./types\";\n\nfunction ligatureForPair(left: string, right: string): string | null {\n  if (left === \"क\" && (right === \"ष\" || right === \"श\")) return \"क्ष\";\n  if (left === \"ज\" && right === \"ञ\") return \"ज्ञ\";\n  if (left === \"त\" && right === \"य\") return \"त्य\";\n  if (left === \"ग\" && right === \"य\") return \"ज्ञ\";\n  return null;\n}\n\nexport const applyLigatureRule: RuleFn = (tokens: Token[], _ctx: RuleContext): Token[] => {\n  const out: Token[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const t0 = tokens[i];\n    const t1 = tokens[i + 1];\n    const t2 = tokens[i + 2];\n\n    if (t0?.kind === \"consonant\" && t1?.kind === \"halant\" && t2?.kind === \"consonant\") {\n      const ligature = ligatureForPair(t0.glyph, t2.glyph);\n      if (ligature) {\n        out.push({ kind: \"consonant\", glyph: ligature });\n        i += 2;\n        continue;\n      }\n    }\n\n    out.push(t0);\n  }\n\n  return out;\n};\n","export type NasalizationMode = \"anusvara\" | \"panchamakshar\";\n\nexport interface EngineRuleOptions {\n  enableNukta: boolean;\n  nasalizationMode: NasalizationMode;\n  enableLigatureCollapse: boolean;\n  enableSchwaDeletion: boolean;\n}\n\nexport type Token =\n  | { kind: \"consonant\"; glyph: string }\n  | { kind: \"vowelIndependent\"; glyph: string }\n  | { kind: \"matra\"; glyph: string }\n  | { kind: \"inherentA\" }\n  | { kind: \"mark\"; glyph: string }\n  | { kind: \"halant\"; glyph: string }\n  | { kind: \"raw\"; text: string };\n\nexport interface RuleContext {\n  options: EngineRuleOptions;\n}\n\nexport type RuleFn = (tokens: Token[], ctx: RuleContext) => Token[];\n\nexport const HALANT = \"्\";\nexport const ANUSVARA = \"ं\";\n\nexport function isWordBoundaryToken(token: Token): boolean {\n  if (token.kind !== \"raw\") {\n    return false;\n  }\n  return /[\\s.,!?;:()[\\]{}'\"-]/u.test(token.text);\n}\n","import type { RuleContext, RuleFn, Token } from \"./types\";\nimport { ANUSVARA } from \"./types\";\n\nconst NASAL_GLYPHS = new Set([\"ङ\", \"ञ\", \"ण\", \"न\", \"म\"]);\nconst VARGA_TO_NASAL: Array<{ chars: Set<string>; nasal: string }> = [\n  { chars: new Set([\"क\", \"ख\", \"ग\", \"घ\"]), nasal: \"ङ\" },\n  { chars: new Set([\"च\", \"छ\", \"ज\", \"झ\"]), nasal: \"ञ\" },\n  { chars: new Set([\"ट\", \"ठ\", \"ड\", \"ढ\"]), nasal: \"ण\" },\n  { chars: new Set([\"त\", \"थ\", \"द\", \"ध\"]), nasal: \"न\" },\n  { chars: new Set([\"प\", \"फ\", \"ब\", \"भ\"]), nasal: \"म\" }\n];\n\nfunction mappedPanchama(target: string): string | null {\n  for (const group of VARGA_TO_NASAL) {\n    if (group.chars.has(target)) {\n      return group.nasal;\n    }\n  }\n  return null;\n}\n\nexport const applyNasalizationRule: RuleFn = (tokens: Token[], ctx: RuleContext): Token[] => {\n  const out: Token[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const t0 = tokens[i];\n    const t1 = tokens[i + 1];\n    const t2 = tokens[i + 2];\n\n    const isNasalCluster =\n      t0?.kind === \"consonant\" &&\n      NASAL_GLYPHS.has(t0.glyph) &&\n      t1?.kind === \"halant\" &&\n      t2?.kind === \"consonant\";\n\n    if (!isNasalCluster) {\n      out.push(t0);\n      continue;\n    }\n\n    if (ctx.options.nasalizationMode === \"anusvara\") {\n      out.push({ kind: \"mark\", glyph: ANUSVARA });\n      i += 1;\n      continue;\n    }\n\n    const mapped = mappedPanchama(t2.glyph);\n    if (!mapped) {\n      out.push(t0);\n      continue;\n    }\n\n    out.push({ kind: \"consonant\", glyph: mapped });\n  }\n\n  return out;\n};\n","import type { RuleContext, RuleFn, Token } from \"./types\";\n\nfunction isRaw(token: Token | undefined, text: string): boolean {\n  return token?.kind === \"raw\" && token.text === text;\n}\n\nfunction isConsonant(token: Token | undefined, glyph: string): boolean {\n  return token?.kind === \"consonant\" && token.glyph === glyph;\n}\n\nfunction isIndependentA(token: Token | undefined): boolean {\n  return token?.kind === \"vowelIndependent\" && token.glyph === \"अ\";\n}\n\nfunction pushWithOptionalAkar(out: Token[], consonantGlyph: string, next: Token | undefined): boolean {\n  out.push({ kind: \"consonant\", glyph: consonantGlyph });\n  if (isIndependentA(next)) {\n    out.push({ kind: \"matra\", glyph: \"ा\" });\n    return true;\n  }\n  return false;\n}\n\nexport const applyNuktaRule: RuleFn = (tokens: Token[], _ctx: RuleContext): Token[] => {\n  const out: Token[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const current = tokens[i];\n    const next = tokens[i + 1];\n\n    if (isConsonant(current, \"क\") && isRaw(next, \"*\")) {\n      const nextAfterStar = tokens[i + 2];\n      const consumedA = pushWithOptionalAkar(out, \"क़\", nextAfterStar);\n      if (consumedA) {\n        i += 2;\n        continue;\n      }\n      i += 1;\n      continue;\n    }\n\n    if (isConsonant(current, \"ग\") && isRaw(next, \"*\")) {\n      const nextAfterStar = tokens[i + 2];\n      const consumedA = pushWithOptionalAkar(out, \"ग़\", nextAfterStar);\n      if (consumedA) {\n        i += 2;\n        continue;\n      }\n      i += 1;\n      continue;\n    }\n\n    if (isRaw(current, \"q\")) {\n      const consumedA = pushWithOptionalAkar(out, \"क़\", next);\n      if (consumedA) {\n        i += 1;\n      }\n      continue;\n    }\n\n    if (isRaw(current, \"f\")) {\n      const consumedA = pushWithOptionalAkar(out, \"फ़\", next);\n      if (consumedA) {\n        i += 1;\n      }\n      continue;\n    }\n\n    out.push(current);\n  }\n\n  return out;\n};\n","import type { RuleContext, RuleFn, Token } from \"./types\";\nimport { ANUSVARA, isWordBoundaryToken } from \"./types\";\n\nfunction isConsonantGlyph(token: Token | undefined, glyph: string): boolean {\n  return token?.kind === \"consonant\" && token.glyph === glyph;\n}\n\nfunction isMatraGlyph(token: Token | undefined, glyph: string): boolean {\n  return token?.kind === \"matra\" && token.glyph === glyph;\n}\n\nfunction isMarkGlyph(token: Token | undefined, glyph: string): boolean {\n  return token?.kind === \"mark\" && token.glyph === glyph;\n}\n\nfunction isKind(token: Token | undefined, kind: Token[\"kind\"]): boolean {\n  return token?.kind === kind;\n}\n\nfunction isWordEnd(tokens: Token[], index: number): boolean {\n  const next = tokens[index + 1];\n  return !next || isWordBoundaryToken(next);\n}\n\nexport const applySchwaRule: RuleFn = (tokens: Token[], _ctx: RuleContext): Token[] => {\n  const out = tokens.map((t) => ({ ...t } as Token));\n\n  for (let i = 0; i < out.length; i += 1) {\n    // Pattern: ... ं + consonant + inherentA at word end => ... ं + consonant + ा\n    if (\n      isMarkGlyph(out[i], ANUSVARA) &&\n      isKind(out[i + 1], \"consonant\") &&\n      isKind(out[i + 2], \"inherentA\") &&\n      isWordEnd(out, i + 2)\n    ) {\n      out[i + 2] = { kind: \"matra\", glyph: \"ा\" };\n    }\n\n    // Pattern: क + inherentA + य at word end => काय\n    if (\n      isConsonantGlyph(out[i], \"क\") &&\n      isKind(out[i + 1], \"inherentA\") &&\n      isConsonantGlyph(out[i + 2], \"य\") &&\n      isWordEnd(out, i + 2)\n    ) {\n      out[i + 1] = { kind: \"matra\", glyph: \"ा\" };\n    }\n\n    // Pattern: क़ + inherentA at word end => क़ा (qa / k*a expectation)\n    if (\n      isConsonantGlyph(out[i], \"क़\") &&\n      isKind(out[i + 1], \"inherentA\") &&\n      isWordEnd(out, i + 1)\n    ) {\n      out[i + 1] = { kind: \"matra\", glyph: \"ा\" };\n    }\n\n    // Verb family: ... र् + त + inherentA + य at word end => ... र + त + ा + य\n    if (\n      isConsonantGlyph(out[i], \"र\") &&\n      isKind(out[i + 1], \"halant\") &&\n      isConsonantGlyph(out[i + 2], \"त\") &&\n      isKind(out[i + 3], \"inherentA\") &&\n      isConsonantGlyph(out[i + 4], \"य\") &&\n      isWordEnd(out, i + 4)\n    ) {\n      out.splice(i + 1, 1);\n      out[i + 2] = { kind: \"matra\", glyph: \"ा\" };\n    }\n\n    // Verb family: ... र् + त + ो + स at word end => ... र + त + ो + स\n    if (\n      isConsonantGlyph(out[i], \"र\") &&\n      isKind(out[i + 1], \"halant\") &&\n      isConsonantGlyph(out[i + 2], \"त\") &&\n      isMatraGlyph(out[i + 3], \"ो\") &&\n      isConsonantGlyph(out[i + 4], \"स\") &&\n      isWordEnd(out, i + 4)\n    ) {\n      out.splice(i + 1, 1);\n    }\n  }\n\n  return out;\n};\n","import { applyLigatureRule } from \"./ligature\";\nimport { applyNasalizationRule } from \"./nasalization\";\nimport { applyNuktaRule } from \"./nukta\";\nimport { applySchwaRule } from \"./schwa\";\nimport type { RuleContext, Token } from \"./types\";\n\nexport function runRulePipeline(tokens: Token[], ctx: RuleContext): Token[] {\n  const withNukta = ctx.options.enableNukta ? applyNuktaRule(tokens, ctx) : tokens;\n  const withNasal = applyNasalizationRule(withNukta, ctx);\n  const withLigatures = ctx.options.enableLigatureCollapse ? applyLigatureRule(withNasal, ctx) : withNasal;\n  const withSchwa = ctx.options.enableSchwaDeletion ? applySchwaRule(withLigatures, ctx) : withLigatures;\n  return withSchwa;\n}\n","import { buildTrie, walkLongest, type TrieNode } from \"./trie\";\nimport { createInputStack } from \"./input-stack\";\nimport { runRulePipeline } from \"./rules\";\nimport type { EngineRuleOptions, NasalizationMode, RuleContext, Token } from \"./rules/types\";\nimport { HALANT } from \"./rules/types\";\n\nexport type Edit = { backspace: number; insert: string };\n\nexport interface TransliterationEntry {\n  type: string;\n  glyph: string;\n  matra?: string;\n}\n\nexport interface TransliterationEngineOptions {\n  expandedMap: Record<string, TransliterationEntry>;\n  trie?: TrieNode<TransliterationEntry>;\n  rules?: {\n    enableNukta?: boolean;\n    nasalizationMode?: NasalizationMode;\n    enableLigatureCollapse?: boolean;\n    enableSchwaDeletion?: boolean;\n  };\n}\n\nexport interface TransliterationEngine {\n  processChar(char: string): Edit;\n  processText(text: string): Edit;\n  backspace(): Edit;\n  commit(): Edit;\n  reset(): void;\n}\n\ntype ContextState = \"start\" | \"afterConsonant\" | \"afterVowel\" | \"other\";\n\nconst DEFAULT_RULES: EngineRuleOptions = {\n  enableNukta: true,\n  nasalizationMode: \"anusvara\",\n  enableLigatureCollapse: true,\n  enableSchwaDeletion: true\n};\n\nfunction isSeparator(char: string): boolean {\n  return /[\\s.,!?;:()[\\]{}\"'-]/u.test(char);\n}\n\nfunction nextContextForRawChar(ch: string): ContextState {\n  if (/\\s/u.test(ch)) {\n    return \"start\";\n  }\n  return \"other\";\n}\n\nfunction isConsonantToken(token: Token): token is Extract<Token, { kind: \"consonant\" }> {\n  return token.kind === \"consonant\";\n}\n\nfunction renderEntryToTokens(entry: TransliterationEntry, context: ContextState): { tokens: Token[]; context: ContextState } {\n  if (entry.type === \"vowel\") {\n    if (context === \"afterConsonant\") {\n      if ((entry.matra ?? \"\") === \"\") {\n        return { tokens: [{ kind: \"inherentA\" }], context: \"afterVowel\" };\n      }\n      return { tokens: [{ kind: \"matra\", glyph: entry.matra ?? \"\" }], context: \"afterVowel\" };\n    }\n\n    return { tokens: [{ kind: \"vowelIndependent\", glyph: entry.glyph }], context: \"afterVowel\" };\n  }\n\n  if (entry.type === \"consonant\" || entry.type === \"conjunct\") {\n    return { tokens: [{ kind: \"consonant\", glyph: entry.glyph }], context: \"afterConsonant\" };\n  }\n\n  if (entry.type === \"mark\") {\n    return { tokens: [{ kind: \"mark\", glyph: entry.glyph }], context };\n  }\n\n  return { tokens: [{ kind: \"raw\", text: entry.glyph }], context };\n}\n\nfunction insertHalants(tokens: Token[]): Token[] {\n  const out: Token[] = [];\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const current = tokens[i];\n    const next = tokens[i + 1];\n\n    out.push(current);\n\n    if (!isConsonantToken(current)) {\n      continue;\n    }\n\n    if (next && isConsonantToken(next)) {\n      out.push({ kind: \"halant\", glyph: HALANT });\n    }\n  }\n\n  return out;\n}\n\nfunction tokenizeBuffer(\n  buffer: string,\n  trie: TrieNode<TransliterationEntry>\n): Token[] {\n  const rawTokens: Token[] = [];\n  let index = 0;\n  let context: ContextState = \"start\";\n\n  while (index < buffer.length) {\n    const match = walkLongest(trie, buffer, index);\n    if (match.matched && match.value) {\n      const shouldSplitNg =\n        match.key === \"ng\" &&\n        index + match.length < buffer.length &&\n        /[aAiIuUeEoOāīū]/u.test(buffer[index + match.length]);\n\n      if (shouldSplitNg) {\n        const nMatch = walkLongest(trie, \"n\");\n        if (nMatch.matched && nMatch.value) {\n          const renderedN = renderEntryToTokens(nMatch.value, context);\n          rawTokens.push(...renderedN.tokens);\n          context = renderedN.context;\n          index += 1;\n          continue;\n        }\n      }\n\n      const rendered = renderEntryToTokens(match.value, context);\n      rawTokens.push(...rendered.tokens);\n      context = rendered.context;\n      index += match.length;\n      continue;\n    }\n\n    const raw = buffer[index];\n      rawTokens.push({ kind: \"raw\", text: raw });\n    context = nextContextForRawChar(raw);\n    index += 1;\n  }\n\n  return insertHalants(rawTokens);\n}\n\nfunction stringifyTokens(tokens: Token[]): string {\n  let out = \"\";\n\n  for (const token of tokens) {\n    if (token.kind === \"inherentA\") {\n      continue;\n    }\n\n    if (token.kind === \"raw\") {\n      out += token.text;\n      continue;\n    }\n\n    out += token.glyph;\n  }\n\n  return out;\n}\n\nfunction computeRendered(\n  raw: string,\n  trie: TrieNode<TransliterationEntry>,\n  ruleOptions: EngineRuleOptions\n): string {\n  const baseTokens = tokenizeBuffer(raw, trie);\n  const ctx: RuleContext = { options: ruleOptions };\n  const postProcessedTokens = runRulePipeline(baseTokens, ctx);\n  return stringifyTokens(postProcessedTokens);\n}\n\nexport function createTransliterationEngine(options: TransliterationEngineOptions): TransliterationEngine {\n  const trie = options.trie ?? buildTrie(options.expandedMap);\n  const ruleOptions: EngineRuleOptions = {\n    ...DEFAULT_RULES,\n    ...(options.rules ?? {})\n  };\n  const inputStack = createInputStack();\n\n  let renderedBuffer = \"\";\n\n  function rewriteFromCurrentInput(): Edit {\n    const nextRendered = computeRendered(inputStack.toString(), trie, ruleOptions);\n    const edit: Edit = {\n      backspace: renderedBuffer.length,\n      insert: nextRendered\n    };\n    renderedBuffer = nextRendered;\n    return edit;\n  }\n\n  return {\n    processChar(char: string): Edit {\n      if (isSeparator(char)) {\n        inputStack.clear();\n        renderedBuffer = \"\";\n        return { backspace: 0, insert: char };\n      }\n\n      inputStack.push(char);\n      return rewriteFromCurrentInput();\n    },\n    processText(text: string): Edit {\n      // For pasted text, we transliterate the entire string at once\n      // Clear current buffer and process the full text\n      inputStack.clear();\n      \n      // Split by separators and process each chunk\n      const chunks = text.split(/(\\s+|[.,!?;:()[\\]{}'\"-])/);\n      let result = \"\";\n      \n      for (const chunk of chunks) {\n        if (isSeparator(chunk) || chunk === \"\") {\n          result += chunk;\n        } else {\n          // Transliterate the chunk\n          result += computeRendered(chunk, trie, ruleOptions);\n        }\n      }\n      \n      const edit: Edit = { backspace: renderedBuffer.length, insert: result };\n      renderedBuffer = result;\n      return edit;\n    },\n    backspace(): Edit {\n      if (inputStack.isEmpty()) {\n        return { backspace: 0, insert: \"\" };\n      }\n\n      inputStack.pop();\n      return rewriteFromCurrentInput();\n    },\n    commit(): Edit {\n      if (inputStack.isEmpty()) {\n        return { backspace: 0, insert: \"\" };\n      }\n\n      inputStack.clear();\n      renderedBuffer = \"\";\n      return { backspace: 0, insert: \"\" };\n    },\n    reset(): void {\n      inputStack.clear();\n      renderedBuffer = \"\";\n    }\n  };\n}\n","export type TextInputLike = HTMLInputElement | HTMLTextAreaElement;\n\nfunction normalizeSelection(el: TextInputLike): { start: number; end: number } {\n  const valueLength = el.value.length;\n  const start = el.selectionStart ?? valueLength;\n  const end = el.selectionEnd ?? valueLength;\n  return {\n    start: Math.max(0, Math.min(start, valueLength)),\n    end: Math.max(0, Math.min(end, valueLength))\n  };\n}\n\nfunction emitInputEvent(el: TextInputLike): void {\n  try {\n    const evt = new InputEvent(\"input\", {\n      bubbles: true,\n      cancelable: false,\n      inputType: \"insertText\",\n      data: null\n    });\n    el.dispatchEvent(evt);\n  } catch {\n    const evt = new Event(\"input\", { bubbles: true, cancelable: false });\n    el.dispatchEvent(evt);\n  }\n}\n\nexport function deleteAndInsert(\n  el: TextInputLike,\n  backspace: number,\n  insert: string\n): { start: number; end: number } {\n  const { start, end } = normalizeSelection(el);\n  const deleteStart = Math.max(0, start - Math.max(0, backspace));\n\n  if (typeof el.setRangeText === \"function\") {\n    el.setRangeText(insert, deleteStart, end, \"end\");\n  } else {\n    const next = `${el.value.slice(0, deleteStart)}${insert}${el.value.slice(end)}`;\n    el.value = next;\n    const caret = deleteStart + insert.length;\n    el.setSelectionRange(caret, caret);\n  }\n\n  emitInputEvent(el);\n  const caret = deleteStart + insert.length;\n  return { start: caret, end: caret };\n}\n\nexport class DOMIntegrator {\n  private readonly element?: TextInputLike;\n\n  constructor(element?: TextInputLike) {\n    this.element = element;\n  }\n\n  deleteAndInsert(el: TextInputLike, backspace: number, insert: string): { start: number; end: number };\n  deleteAndInsert(backspace: number, insert: string): { start: number; end: number };\n  deleteAndInsert(\n    arg1: TextInputLike | number,\n    arg2: number | string,\n    arg3?: string\n  ): { start: number; end: number } {\n    if (typeof arg1 === \"number\") {\n      if (!this.element || typeof arg2 !== \"string\") {\n        throw new Error(\"DOMIntegrator requires a bound element for deleteAndInsert(backspace, insert).\");\n      }\n      return deleteAndInsert(this.element, arg1, arg2);\n    }\n\n    if (typeof arg2 !== \"number\" || typeof arg3 !== \"string\") {\n      throw new Error(\"deleteAndInsert(el, backspace, insert) requires all arguments.\");\n    }\n\n    return deleteAndInsert(arg1, arg2, arg3);\n  }\n}\n","export interface ContentEditableEditResult {\n  collapsed: boolean;\n  applied: boolean;\n}\n\nfunction ensureSingleTextNode(root: HTMLElement): Text {\n  if (root.childNodes.length === 0) {\n    const text = root.ownerDocument.createTextNode(\"\");\n    root.appendChild(text);\n    return text;\n  }\n\n  if (root.childNodes.length === 1 && root.firstChild?.nodeType === Node.TEXT_NODE) {\n    return root.firstChild as Text;\n  }\n\n  const flattened = root.textContent ?? \"\";\n  root.textContent = \"\";\n  const text = root.ownerDocument.createTextNode(flattened);\n  root.appendChild(text);\n  return text;\n}\n\nexport function deleteAndInsertContentEditable(\n  root: HTMLElement,\n  backspace: number,\n  insert: string\n): ContentEditableEditResult {\n  const selection = root.ownerDocument.getSelection();\n  if (!selection || selection.rangeCount === 0) {\n    return { collapsed: false, applied: false };\n  }\n\n  const range = selection.getRangeAt(0);\n  if (!range.collapsed || !root.contains(range.startContainer)) {\n    return { collapsed: false, applied: false };\n  }\n\n  const textNode = ensureSingleTextNode(root);\n  const value = textNode.data;\n\n  let caret = value.length;\n  if (range.startContainer === textNode) {\n    caret = Math.max(0, Math.min(range.startOffset, value.length));\n  }\n\n  const deleteStart = Math.max(0, caret - Math.max(0, backspace));\n  const next = `${value.slice(0, deleteStart)}${insert}${value.slice(caret)}`;\n  textNode.data = next;\n\n  const nextCaret = deleteStart + insert.length;\n  const nextRange = root.ownerDocument.createRange();\n  nextRange.setStart(textNode, nextCaret);\n  nextRange.collapse(true);\n  selection.removeAllRanges();\n  selection.addRange(nextRange);\n\n  return { collapsed: true, applied: true };\n}\n","import { deleteAndInsert, type TextInputLike } from \"./dom-integrator\";\nimport { deleteAndInsertContentEditable } from \"./contenteditable-edit\";\nimport type { Edit, TransliterationEngine } from \"../engine/transliteration-engine\";\n\nexport type InterceptTarget = TextInputLike | HTMLElement;\n\nexport interface InputInterceptorOptions {\n  element: InterceptTarget;\n  engine: TransliterationEngine;\n  enabled?: boolean;\n  onEditApplied?: (edit: Edit) => void;\n  onBypass?: (reason: \"disabled\" | \"modifier\" | \"composition\" | \"unsupported-target\" | \"selection\") => void;\n}\n\nexport interface InputInterceptor {\n  attach(): void;\n  detach(): void;\n  isAttached(): boolean;\n}\n\nfunction isTextInputLike(el: Element): el is TextInputLike {\n  if (el instanceof HTMLTextAreaElement) {\n    return true;\n  }\n\n  if (el instanceof HTMLInputElement) {\n    return el.type === \"text\";\n  }\n\n  return false;\n}\n\nfunction isSupportedContentEditable(el: Element): el is HTMLElement {\n  return el instanceof HTMLElement && el.isContentEditable;\n}\n\nfunction hasModifier(evt: KeyboardEvent): boolean {\n  return evt.ctrlKey || evt.altKey || evt.metaKey;\n}\n\nfunction isCommitKey(key: string): boolean {\n  return key === \" \" || key === \"Enter\" || key === \"Tab\";\n}\n\nexport function createInputInterceptor(options: InputInterceptorOptions): InputInterceptor {\n  const element = options.element;\n  const engine = options.engine;\n  const onEditApplied = options.onEditApplied;\n  const onBypass = options.onBypass;\n  let enabled = options.enabled ?? true;\n  let attached = false;\n  let isComposing = false;\n\n  const applyEdit = (edit: Edit): boolean => {\n    if (isTextInputLike(element)) {\n      deleteAndInsert(element, edit.backspace, edit.insert);\n      onEditApplied?.(edit);\n      return true;\n    }\n\n    if (isSupportedContentEditable(element)) {\n      const result = deleteAndInsertContentEditable(element, edit.backspace, edit.insert);\n      if (!result.collapsed) {\n        onBypass?.(\"selection\");\n        return false;\n      }\n      if (!result.applied) {\n        return false;\n      }\n      onEditApplied?.(edit);\n      return true;\n    }\n\n    onBypass?.(\"unsupported-target\");\n    return false;\n  };\n\n  const handleCompositionStart = (): void => {\n    isComposing = true;\n  };\n\n  const handleCompositionEnd = (): void => {\n    isComposing = false;\n  };\n\n  const handleKeydown = (evt: KeyboardEvent): void => {\n    if (!enabled) {\n      onBypass?.(\"disabled\");\n      return;\n    }\n\n    if (hasModifier(evt)) {\n      onBypass?.(\"modifier\");\n      return;\n    }\n\n    if (isComposing) {\n      onBypass?.(\"composition\");\n      return;\n    }\n\n    if (isCommitKey(evt.key)) {\n      // Allow native insertion, but finalize current composition so next input starts fresh.\n      engine.commit();\n      return;\n    }\n\n    if (evt.key !== \"Backspace\") {\n      return;\n    }\n\n    const edit = engine.backspace();\n    if (edit.backspace === 0 && edit.insert === \"\") {\n      // No active IME composition to rewrite; let native backspace behavior run.\n      return;\n    }\n\n    if (!applyEdit(edit)) {\n      return;\n    }\n\n    evt.preventDefault();\n  };\n\n  const handleBeforeInput = (evt: InputEvent): void => {\n    if (!enabled) {\n      onBypass?.(\"disabled\");\n      return;\n    }\n\n    if (isComposing) {\n      onBypass?.(\"composition\");\n      return;\n    }\n\n    if (evt.inputType !== \"insertText\") {\n      return;\n    }\n\n    const text = evt.data;\n    if (!text) {\n      return;\n    }\n\n    // Use processText for multi-character input (paste), processChar for single character\n    const edit = text.length > 1 ? engine.processText(text) : engine.processChar(text);\n    if (!applyEdit(edit)) {\n      return;\n    }\n\n    evt.preventDefault();\n  };\n\n  return {\n    attach(): void {\n      if (attached) {\n        return;\n      }\n\n      element.addEventListener(\"compositionstart\", handleCompositionStart);\n      element.addEventListener(\"compositionend\", handleCompositionEnd);\n      element.addEventListener(\"keydown\", handleKeydown as EventListener);\n      element.addEventListener(\"beforeinput\", handleBeforeInput as EventListener);\n      attached = true;\n    },\n    detach(): void {\n      if (!attached) {\n        return;\n      }\n\n      element.removeEventListener(\"compositionstart\", handleCompositionStart);\n      element.removeEventListener(\"compositionend\", handleCompositionEnd);\n      element.removeEventListener(\"keydown\", handleKeydown as EventListener);\n      element.removeEventListener(\"beforeinput\", handleBeforeInput as EventListener);\n      attached = false;\n    },\n    isAttached(): boolean {\n      return attached;\n    }\n  };\n}\n"],"mappings":"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","names":["index_exports","__export","DOMIntegrator","buildTrie","createInputInterceptor","createInputStack","createTransliterationEngine","deleteAndInsert","deleteAndInsertContentEditable","base_default","maps","phonetic_base_default","phonetic_expanded_default","walkLongest","__toCommonJS","base_default","phonetic_base_default","phonetic_expanded_default","createNode","buildTrie","expandedMap","root","key","value","node","ch","child","walkLongest","input","startIndex","index","matchedLength","matchedKey","matchedValue","next","createInputStack","parts","char","ligatureForPair","left","right","applyLigatureRule","tokens","_ctx","out","i","t0","t1","t2","ligature","isWordBoundaryToken","token","NASAL_GLYPHS","VARGA_TO_NASAL","mappedPanchama","target","group","applyNasalizationRule","tokens","ctx","out","i","t0","t1","t2","mapped","isRaw","token","text","isConsonant","glyph","isIndependentA","pushWithOptionalAkar","out","consonantGlyph","next","applyNuktaRule","tokens","_ctx","i","current","nextAfterStar","isConsonantGlyph","token","glyph","isMatraGlyph","isMarkGlyph","isKind","kind","isWordEnd","tokens","index","next","isWordBoundaryToken","applySchwaRule","_ctx","out","i","runRulePipeline","tokens","ctx","withNukta","applyNuktaRule","withNasal","applyNasalizationRule","withLigatures","applyLigatureRule","applySchwaRule","DEFAULT_RULES","isSeparator","char","nextContextForRawChar","ch","isConsonantToken","token","renderEntryToTokens","entry","context","insertHalants","tokens","out","i","current","next","tokenizeBuffer","buffer","trie","rawTokens","index","match","walkLongest","nMatch","renderedN","rendered","raw","stringifyTokens","computeRendered","ruleOptions","baseTokens","postProcessedTokens","runRulePipeline","createTransliterationEngine","options","buildTrie","inputStack","createInputStack","renderedBuffer","rewriteFromCurrentInput","nextRendered","edit","text","chunks","result","chunk","normalizeSelection","el","valueLength","start","end","emitInputEvent","evt","deleteAndInsert","backspace","insert","deleteStart","next","caret","DOMIntegrator","element","arg1","arg2","arg3","ensureSingleTextNode","root","text","flattened","deleteAndInsertContentEditable","backspace","insert","selection","range","textNode","value","caret","deleteStart","next","nextCaret","nextRange","isTextInputLike","el","isSupportedContentEditable","hasModifier","evt","isCommitKey","key","createInputInterceptor","options","element","engine","onEditApplied","onBypass","enabled","attached","isComposing","applyEdit","edit","deleteAndInsert","result","deleteAndInsertContentEditable","handleCompositionStart","handleCompositionEnd","handleKeydown","handleBeforeInput","text","maps","base_default","phonetic_base_default","phonetic_expanded_default"]}